Команда: Дарья Туричина, Владислав Мильшин, Александр Марьинский

## Read-Execute-Print-Loop
При старте программы запускатеся метод run() в readExecPrintLoop. Этот класс отвечает за считывание команд пользователя и возвращение ему результата исполнения или сообщения об ошибке. Метод run работает бесконечно пока мы не получили от пользователя команду exit. Он также хранит текущие значения переменных окружения.

При получении команды от пользователя мы сперва осуществляем препроцессинг, потом исполнение команды, а потом выводим пользователю результат исполнения и сообщения об ошибках если они есть.

## Препроцессинг

В ходе препроцессинга из исходной строки получается preprocessedPipelineString - массив preprocessedCommandString, каждая из которых соответствует команде и представляет из себя массив строк (токенов), где сначала идут опциональные определения переменных окружения, потом название команды и потом её аргументы.
Препроцессинг происходит в методе createPreprocessedPipelineString класса preprocessor, который может кинуть исключение parsingError. Исходная строка преобразуется в несколько этапов.

### Первая фаза

В первой фазе строка только разбивается на элементарные единицы. createPreprocessedPipelineString использует метод tokenize, который обрабатывает строку посимвольно слева направо. При обработке каждого символа обработчик находится в одном из состояний:
<ul>
<li>NO_QUOTE_OPEN</li>
<li>SINGLE_QUOTE_OPEN</li>
<li>DOUBLE_QUOTE_OPEN</li>
</ul>
Переходы между состояниями:
<ul>
<li>NO_QUOTE_OPEN<->SINGLE_QUOTE_OPEN при обработке символа '</li>
<li>NO_QUOTE_OPEN<->DOUBLE_QUOTE_OPEN при обработке символа "</li>
</ul>

Обработчик записывает символы в результирующий preprocessedPipelineString по правилам
<ol>
<li> в состоянии NO_QUOTE_OPEN
<ul>
<li>по пробельным символам ' \n\t' осуществляется переход к следующему токену в preprocessedCommandString, </li>
<li>по символу '|' осуществляется переход к следующему элементу типа preprocessedCommandString в preprocessedPipelineString, </li>
<li>пустые токены не пишутся в preprocessedCommandString, </li>
</ul>
</li>
<li> остальные символы в NO_QUOTE_OPEN и все символы (кроме соответствующих кавычек) в SINGLE_QUOTE_OPEN, DOUBLE_QUOTE_OPEN записываются в текущий токен, </li>
<li> символы перехода между состояниями и символы '| \n\t' в состоянии NO_QUOTE_OPEN не записываются в ответ. </li>
</ol>
Если исходная строка закончилась, но состояние не NO_QUOTE_OPEN, или, если в preprocessedPipelineString более одной preprocessedCommandString, но последняя пустая, tokenize бросает исключение ParsingError, которое через createPreprocessedPipelineString пробрасывается наружу в readExecPrintLoop.run().

### Вторая фаза

Вторая фаза реализует подстановку переменных окружения. Переменные поставляет readExecPrintLoop в аргументе variables типа variableStorage, который инкапсулирует работу с ними и предоставляет методы set(name, value), сохраняющий значение переменной, и get(name), который возвращает значение переменной, если оно было ранее сохранено, и пустую строку иначе (препроцессор использует только get). Имена переменных могут содержать только латинские буквы, цифры и нижнее подчеркивание.

Сначала createPreprocessedPipelineString вызывает метод substitute(input), который подставляет значения переменных. substitute проходит по строке аналогично методу tokenize и если встречает символ '$' в состояниях NO_QUOTE_OPEN, DOUBLE_QUOTE_OPEN, то определяет имя переменной как подстроку от $ до первого символа, не являющегося латинской буквой, цифрой или знаком подчеркивания (или до конца строки), выписывает в ответ variables.get(variable_name) и продолжает процессинг со следующего в исходной строке после имени переменной символа. Таким образом подстановка происходит один раз в самом начале и циклы невозможны. 

Полученную после подстановок строку tokenizer разделяет на токены как и в первой фазе.

В принципе возможно такой парсинг выполнять за один проход, но метод substitute выделен для логического и структурного разденения на фазы.

В результате createPreprocessedPipelineString или вылетает исключение, которое обрабатывается в readExecPrintLoop.run(), или возвращается массив предобработанных комманд, которые далее исполняются друг за другом.

## Исполнение
После препроцессинга preprocessedPipelineString попадает в executor где из подготовленных строк создаются и исполняются команды. executor возвращает commandResult. commandResult хранит поток вывода, поток ошибок, код выхода, а также флаг needExit. 

### Первая фаза
В методе execute мы создаем с помощью commandFactory команду из единственной preprocessedCommandString, потока ввода и потока ошибок. После этого мы исполняем созданную команду. 

За команды отвечает класс commandBase и его наследники catCommand, echoCommand, wcCommand, pwdCommand, exitCommand и externalCommand. comandBase имеет метод execute() отвечающий за выполнение команды. При выполнении он возращает commandResult. 

### Вторая фаза
В методе execute мы последовательно проходим по каждой preprocessedCommandString в preprocessedPipelineString, создаем команду, определяем для нее окружение и исполняем её. При исполнении мы сохраняем поток вывода текущей команды чтобы передать его следующей команде в качестве потока ввода в конструкторе.

По окончании выполнения последней команды пайплана итоговый commandResult возвращается в readExecPrintLoop. Если одна из команд пайплайна возвращает результат с флагом need_exit==true или кодом выхода отличным от нуля, то исполнение пайплайна завершается и результат последней команды возвращается в readExecPrintLoop.

Во второй фазе из readExecPrintLoop в execute передаются переменные окружения как variableStorage, а перед созданием каждой команды появляется дополнительная фаза. В методе getLocalEnvironment(preprocessedCommandString) для каждой команды определяются локальные переменные окружения, а именно: все начальные токены удовлетворяющие паттерну [a-zA-Z_][a-zA-Z_0-9]\*=.\* считаются объявлениями переменных, причем часть токена до символа '=' считается названием переменной name, а после - новым значением value. Все эти токены удаляются из preprocessedCommandString, а полученные переменные возвращаются из getLocalEnvironment как variableStorage. 

Далее если в итоговой preprocessedPipelineString только одна preprocessedCommandString и после выделения переменных она стала пустой, то результат getLocalEnvironment используется для обновления переданного environment через метод set и выполнение заканчивается. Иначе формируется полное окружение для текущей команды как объединение environment и localEnvironment.

После этого команда запускается через её метод execute, в который передаются полученные переменные окружения.

## Стадии разработки
Разработка будет происходить в два этапа.

На первом этапе мы реализуем readExecPrintLoop, упрощенную версию preprocessor и упрощенную версию executor. 

В упрощенной версии preprocessor не будет реализована логика подстановок и пайпов. То есть в нем не будет метода substitute. При этом мы будем использовать класс preprocessedPipelineString, однако на первом этапе разработки мы подразумеваем что в нем хранится только одна preprocessedCommandString. 

В упрощенной версии executor мы не реализуем логику прохода по всем preprocessedCommandString в preprocessedPipelineString а просто созадем и исполняем единственную команду, которая хранится в preprocessedPipelineString. В первой фазе executor и baseCommand не используют переменные окружения. 

На втором этапе разработки мы реализуем недостающиe методы в preprocessor и executor и добавляем логику прохода по всем командам пайпа и сохранения и передачи переменных окружения.

