## Препроцессинг

В ходе препроцессинга из исходной строки получается preprocessedPipelineString - массив preprocessedCommandString, каждая из которых соответствует команде и представляет из себя массив строк (токенов), где нулевой элемент соответствует названию команды, а остальные считаются аргументами.
Препроцессинг происходит в методе createPreprocessedPipelineString класса preprocessor, который может кинуть исключение ParsingError. Исходная строка преобразуется в несколько этапов.

### Первая фаза

В первой фазе строка только разбивается на элементарные единицы. createPreprocessedPipelineString использует метод tokenize, который обрабатывает строку посимвольно слева направо. При обработке каждого символа обработчик находится в одном из состояний:
<ul>
<li>NO_QUOTE_OPEN</li>
<li>SINGLE_QUOTE_OPEN</li>
<li>DOUBLE_QUOTE_OPEN</li>
</ul>
Переходы между состояниями:
<ul>
<li>NO_QUOTE_OPEN<->SINGLE_QUOTE_OPEN при обработке символа '</li>
<li>NO_QUOTE_OPEN<->DOUBLE_QUOTE_OPEN при обработке символа "</li>
</ul>

Обработчик записывает символы в результирующий preprocessedPipelineString по правилам
<ol>
<li> в состоянии NO_QUOTE_OPEN
<ul>
<li>по пробельным символам ' \n\t' осуществляется переход к следующему токену в preprocessedCommandString, </li>
<li>по символу '|' осуществляется переход к следующему элементу типа preprocessedCommandString в preprocessedPipelineString, </li>
<li>пустые токены не пишутся в preprocessedCommandString, </li>
</ul>
</li>
<li> остальные символы в NO_QUOTE_OPEN и все символы (кроме соответствующих кавычек) в SINGLE_QUOTE_OPEN, DOUBLE_QUOTE_OPEN записываются в текущий токен, </li>
<li> символы перехода между состояниями и символы '| \n\t' в состоянии NO_QUOTE_OPEN не записываются в ответ. </li>
</ol>
Если исходная строка закончилась, но состояние не NO_QUOTE_OPEN или если в preprocessedPipelineString более одной preprocessedCommandString, но последняя пустая, tokenize бросает исключение ParsingError, которое через createPreprocessedPipelineString пробрасывается наружу в readExecPrintLoop.run().

### Вторая фаза

Вторая фаза реализует обработку переменных окружения. Переменные preprocessor хранит в поле variables типа variableStorage, который инкапсулирует работу с ними и предоставляет методы set(name, value), сохраняющий значение переменной, и get(name), который возвращает значение переменной, если оно было ранее сохранено, и пустую строку иначе. Имена переменных могут содержать только латинские буквы и цифры.

Сначала createPreprocessedPipelineString вызывает метод substitute(input), который подставляет значения переменных. substitute проходит по строке аналогично методу tokenize и если встречает символ '$' в состояниях NO_QUOTE_OPEN, DOUBLE_QUOTE_OPEN, то определяет имя переменной как подстроку от $ до первого символа, не являющегося латинской буквой или цифрой (или до конца строки), выписывает в ответ variables.get(variable_name) и продолжает процессинг со следующего в исходной строке после имени переменной символа. Таким образом подстановка происходит один раз в самом начале и циклы невозможны. 

Полученную после подстановок строку tokenizer разделяет на токены как и в первой фазе.

После разбиения на токены вызывается метод updateVariables, который обновляет значение переменных, если это необходимо. А именно: если в итоговой preprocessedPipelineString только одна preprocessedCommandString, а в ней только один токен и этот токен имеет вид [a-zA-Z][a-zA-Z0-9]\*=.\*, то часть токена до символа '=' считается названием переменной name, а после - новым значением value и вызывается variables.set(name, value). В противном случае проверяются все первые токены в preprocessedCommandString, на которые разбита preprocessedPipelineString, и если они удовлетвояют этому шаблону, то эти первые токены удаляются из ответа.

В принципе возможно такой парсинг выполнять за один проход, но методы substitute и updateVariables выделены для логического и структурного разденения на фазы.

В результате createPreprocessedPipelineString или вылетает исключение, которое обрабатывается в readExecPrintLoop.run() или возвращается массив комманд, которые далее исполняются друг за другом.
